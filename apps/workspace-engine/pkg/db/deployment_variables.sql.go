// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment_variables.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteDeploymentVariable = `-- name: DeleteDeploymentVariable :exec
DELETE FROM deployment_variable WHERE id = $1
`

func (q *Queries) DeleteDeploymentVariable(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDeploymentVariable, id)
	return err
}

const getDeploymentVariableByID = `-- name: GetDeploymentVariableByID :one
SELECT id, deployment_id, key, description, default_value
FROM deployment_variable
WHERE id = $1
`

func (q *Queries) GetDeploymentVariableByID(ctx context.Context, id uuid.UUID) (DeploymentVariable, error) {
	row := q.db.QueryRow(ctx, getDeploymentVariableByID, id)
	var i DeploymentVariable
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.Key,
		&i.Description,
		&i.DefaultValue,
	)
	return i, err
}

const listDeploymentVariablesByDeploymentID = `-- name: ListDeploymentVariablesByDeploymentID :many
SELECT id, deployment_id, key, description, default_value
FROM deployment_variable
WHERE deployment_id = $1
`

func (q *Queries) ListDeploymentVariablesByDeploymentID(ctx context.Context, deploymentID uuid.UUID) ([]DeploymentVariable, error) {
	rows, err := q.db.Query(ctx, listDeploymentVariablesByDeploymentID, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentVariable
	for rows.Next() {
		var i DeploymentVariable
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.Key,
			&i.Description,
			&i.DefaultValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentVariablesByWorkspaceID = `-- name: ListDeploymentVariablesByWorkspaceID :many
SELECT dv.id, dv.deployment_id, dv.key, dv.description, dv.default_value
FROM deployment_variable dv
INNER JOIN deployment d ON d.id = dv.deployment_id
WHERE d.workspace_id = $1
`

func (q *Queries) ListDeploymentVariablesByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]DeploymentVariable, error) {
	rows, err := q.db.Query(ctx, listDeploymentVariablesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeploymentVariable
	for rows.Next() {
		var i DeploymentVariable
		if err := rows.Scan(
			&i.ID,
			&i.DeploymentID,
			&i.Key,
			&i.Description,
			&i.DefaultValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDeploymentVariable = `-- name: UpsertDeploymentVariable :one
INSERT INTO deployment_variable (id, deployment_id, key, description, default_value)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE
SET deployment_id = EXCLUDED.deployment_id, key = EXCLUDED.key,
    description = EXCLUDED.description, default_value = EXCLUDED.default_value
RETURNING id, deployment_id, key, description, default_value
`

type UpsertDeploymentVariableParams struct {
	ID           uuid.UUID
	DeploymentID uuid.UUID
	Key          string
	Description  pgtype.Text
	DefaultValue []byte
}

func (q *Queries) UpsertDeploymentVariable(ctx context.Context, arg UpsertDeploymentVariableParams) (DeploymentVariable, error) {
	row := q.db.QueryRow(ctx, upsertDeploymentVariable,
		arg.ID,
		arg.DeploymentID,
		arg.Key,
		arg.Description,
		arg.DefaultValue,
	)
	var i DeploymentVariable
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.Key,
		&i.Description,
		&i.DefaultValue,
	)
	return i, err
}
