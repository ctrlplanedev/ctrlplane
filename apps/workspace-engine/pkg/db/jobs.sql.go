// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM job WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, release_id, job_agent_id, workflow_job_id, status, reason, external_id, message, trace_token, job_agent_config, dispatch_context, metadata, created_at, updated_at, started_at, completed_at FROM job WHERE id = $1
`

func (q *Queries) GetJobByID(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.ReleaseID,
		&i.JobAgentID,
		&i.WorkflowJobID,
		&i.Status,
		&i.Reason,
		&i.ExternalID,
		&i.Message,
		&i.TraceToken,
		&i.JobAgentConfig,
		&i.DispatchContext,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listJobsByJobAgentID = `-- name: ListJobsByJobAgentID :many
SELECT id, release_id, job_agent_id, workflow_job_id, status, reason, external_id, message, trace_token, job_agent_config, dispatch_context, metadata, created_at, updated_at, started_at, completed_at FROM job WHERE job_agent_id = $1
`

func (q *Queries) ListJobsByJobAgentID(ctx context.Context, jobAgentID uuid.UUID) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByJobAgentID, jobAgentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.ReleaseID,
			&i.JobAgentID,
			&i.WorkflowJobID,
			&i.Status,
			&i.Reason,
			&i.ExternalID,
			&i.Message,
			&i.TraceToken,
			&i.JobAgentConfig,
			&i.DispatchContext,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByReleaseID = `-- name: ListJobsByReleaseID :many
SELECT id, release_id, job_agent_id, workflow_job_id, status, reason, external_id, message, trace_token, job_agent_config, dispatch_context, metadata, created_at, updated_at, started_at, completed_at FROM job WHERE release_id = $1
`

func (q *Queries) ListJobsByReleaseID(ctx context.Context, releaseID uuid.UUID) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByReleaseID, releaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.ReleaseID,
			&i.JobAgentID,
			&i.WorkflowJobID,
			&i.Status,
			&i.Reason,
			&i.ExternalID,
			&i.Message,
			&i.TraceToken,
			&i.JobAgentConfig,
			&i.DispatchContext,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByStatusAndWorkspace = `-- name: ListJobsByStatusAndWorkspace :many
SELECT j.id, j.release_id, j.job_agent_id, j.workflow_job_id, j.status, j.reason, j.external_id, j.message, j.trace_token, j.job_agent_config, j.dispatch_context, j.metadata, j.created_at, j.updated_at, j.started_at, j.completed_at
FROM job j
JOIN release r ON r.id = j.release_id
JOIN deployment d ON d.id = r.deployment_id
WHERE j.status = $1 AND d.workspace_id = $2
`

type ListJobsByStatusAndWorkspaceParams struct {
	Status      JobStatus
	WorkspaceID uuid.UUID
}

func (q *Queries) ListJobsByStatusAndWorkspace(ctx context.Context, arg ListJobsByStatusAndWorkspaceParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByStatusAndWorkspace, arg.Status, arg.WorkspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.ReleaseID,
			&i.JobAgentID,
			&i.WorkflowJobID,
			&i.Status,
			&i.Reason,
			&i.ExternalID,
			&i.Message,
			&i.TraceToken,
			&i.JobAgentConfig,
			&i.DispatchContext,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByWorkflowJobID = `-- name: ListJobsByWorkflowJobID :many
SELECT id, release_id, job_agent_id, workflow_job_id, status, reason, external_id, message, trace_token, job_agent_config, dispatch_context, metadata, created_at, updated_at, started_at, completed_at FROM job WHERE workflow_job_id = $1
`

func (q *Queries) ListJobsByWorkflowJobID(ctx context.Context, workflowJobID uuid.UUID) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByWorkflowJobID, workflowJobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.ReleaseID,
			&i.JobAgentID,
			&i.WorkflowJobID,
			&i.Status,
			&i.Reason,
			&i.ExternalID,
			&i.Message,
			&i.TraceToken,
			&i.JobAgentConfig,
			&i.DispatchContext,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByWorkspaceID = `-- name: ListJobsByWorkspaceID :many
SELECT j.id, j.release_id, j.job_agent_id, j.workflow_job_id, j.status, j.reason, j.external_id, j.message, j.trace_token, j.job_agent_config, j.dispatch_context, j.metadata, j.created_at, j.updated_at, j.started_at, j.completed_at
FROM job j
JOIN release r ON r.id = j.release_id
JOIN deployment d ON d.id = r.deployment_id
WHERE d.workspace_id = $1
LIMIT COALESCE($2::int, 5000)
`

type ListJobsByWorkspaceIDParams struct {
	WorkspaceID uuid.UUID
	Limit       pgtype.Int4
}

func (q *Queries) ListJobsByWorkspaceID(ctx context.Context, arg ListJobsByWorkspaceIDParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByWorkspaceID, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.ReleaseID,
			&i.JobAgentID,
			&i.WorkflowJobID,
			&i.Status,
			&i.Reason,
			&i.ExternalID,
			&i.Message,
			&i.TraceToken,
			&i.JobAgentConfig,
			&i.DispatchContext,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertJob = `-- name: UpsertJob :one
INSERT INTO job (
    id, release_id, job_agent_id, workflow_job_id,
    status, reason, external_id, message, trace_token,
    job_agent_config, dispatch_context, metadata,
    created_at, updated_at, started_at, completed_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8, $9,
    $10, $11, $12,
    COALESCE($13::timestamptz, NOW()),
    COALESCE($14::timestamptz, NOW()),
    $15::timestamptz,
    $16::timestamptz
)
ON CONFLICT (id) DO UPDATE
SET release_id = EXCLUDED.release_id,
    job_agent_id = EXCLUDED.job_agent_id,
    workflow_job_id = EXCLUDED.workflow_job_id,
    status = EXCLUDED.status,
    reason = EXCLUDED.reason,
    external_id = EXCLUDED.external_id,
    message = EXCLUDED.message,
    trace_token = EXCLUDED.trace_token,
    job_agent_config = EXCLUDED.job_agent_config,
    dispatch_context = EXCLUDED.dispatch_context,
    metadata = EXCLUDED.metadata,
    updated_at = EXCLUDED.updated_at,
    started_at = EXCLUDED.started_at,
    completed_at = EXCLUDED.completed_at
RETURNING id, release_id, job_agent_id, workflow_job_id, status, reason, external_id, message, trace_token, job_agent_config, dispatch_context, metadata, created_at, updated_at, started_at, completed_at
`

type UpsertJobParams struct {
	ID              uuid.UUID
	ReleaseID       uuid.UUID
	JobAgentID      uuid.UUID
	WorkflowJobID   uuid.UUID
	Status          JobStatus
	Reason          interface{}
	ExternalID      pgtype.Text
	Message         pgtype.Text
	TraceToken      pgtype.Text
	JobAgentConfig  map[string]any
	DispatchContext []byte
	Metadata        map[string]string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	StartedAt       pgtype.Timestamptz
	CompletedAt     pgtype.Timestamptz
}

func (q *Queries) UpsertJob(ctx context.Context, arg UpsertJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, upsertJob,
		arg.ID,
		arg.ReleaseID,
		arg.JobAgentID,
		arg.WorkflowJobID,
		arg.Status,
		arg.Reason,
		arg.ExternalID,
		arg.Message,
		arg.TraceToken,
		arg.JobAgentConfig,
		arg.DispatchContext,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.ReleaseID,
		&i.JobAgentID,
		&i.WorkflowJobID,
		&i.Status,
		&i.Reason,
		&i.ExternalID,
		&i.Message,
		&i.TraceToken,
		&i.JobAgentConfig,
		&i.DispatchContext,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}
