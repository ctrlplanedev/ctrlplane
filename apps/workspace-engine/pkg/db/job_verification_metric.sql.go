// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job_verification_metric.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getJobDispatchContext = `-- name: GetJobDispatchContext :one
SELECT j.dispatch_context
FROM job j
JOIN job_verification_metric jvm ON j.id = jvm.job_id
WHERE jvm.id = $1
`

func (q *Queries) GetJobDispatchContext(ctx context.Context, id uuid.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getJobDispatchContext, id)
	var dispatch_context []byte
	err := row.Scan(&dispatch_context)
	return dispatch_context, err
}

const getReleaseTargetForMetric = `-- name: GetReleaseTargetForMetric :one
SELECT
  r.deployment_id,
  r.environment_id,
  r.resource_id,
  d.workspace_id
FROM job_verification_metric jvm
JOIN release_job rj ON rj.job_id = jvm.job_id
JOIN release r ON r.id = rj.release_id
JOIN deployment d ON d.id = r.deployment_id
WHERE jvm.id = $1
`

type GetReleaseTargetForMetricRow struct {
	DeploymentID  uuid.UUID
	EnvironmentID uuid.UUID
	ResourceID    uuid.UUID
	WorkspaceID   uuid.UUID
}

func (q *Queries) GetReleaseTargetForMetric(ctx context.Context, id uuid.UUID) (GetReleaseTargetForMetricRow, error) {
	row := q.db.QueryRow(ctx, getReleaseTargetForMetric, id)
	var i GetReleaseTargetForMetricRow
	err := row.Scan(
		&i.DeploymentID,
		&i.EnvironmentID,
		&i.ResourceID,
		&i.WorkspaceID,
	)
	return i, err
}

const getSiblingMetricStatuses = `-- name: GetSiblingMetricStatuses :many
SELECT
  m.id,
  (
    COALESCE(mc.total, 0) >= m.count
    OR COALESCE(mc.failures, 0) > COALESCE(m.failure_threshold, 0)
  )::boolean AS is_terminal,
  (COALESCE(mc.failures, 0) > COALESCE(m.failure_threshold, 0))::boolean AS is_failed
FROM job_verification_metric m
LEFT JOIN LATERAL (
  SELECT
    COUNT(*)::int AS total,
    COUNT(*) FILTER (WHERE mm.status = 'failed')::int AS failures
  FROM job_verification_metric_measurement mm
  WHERE mm.job_verification_metric_status_id = m.id
) mc ON true
WHERE m.job_id = (SELECT job_id FROM job_verification_metric WHERE id = $1)
`

type GetSiblingMetricStatusesRow struct {
	ID         uuid.UUID
	IsTerminal bool
	IsFailed   bool
}

func (q *Queries) GetSiblingMetricStatuses(ctx context.Context, dollar_1 uuid.UUID) ([]GetSiblingMetricStatusesRow, error) {
	rows, err := q.db.Query(ctx, getSiblingMetricStatuses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSiblingMetricStatusesRow
	for rows.Next() {
		var i GetSiblingMetricStatusesRow
		if err := rows.Scan(&i.ID, &i.IsTerminal, &i.IsFailed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerificationMetricWithMeasurements = `-- name: GetVerificationMetricWithMeasurements :one
SELECT
  jvm.id,
  jvm.created_at,
  jvm.job_id,
  jvm.name,
  jvm.provider,
  jvm.interval_seconds,
  jvm.count,
  jvm.success_condition,
  jvm.success_threshold,
  jvm.failure_condition,
  jvm.failure_threshold,
  COALESCE(
    (SELECT json_agg(
      json_build_object(
        'id', mm.id,
        'metric_id', mm.job_verification_metric_status_id,
        'data', mm.data,
        'measured_at', mm.measured_at,
        'message', mm.message,
        'status', mm.status
      ) ORDER BY mm.measured_at ASC
    )
    FROM job_verification_metric_measurement mm
    WHERE mm.job_verification_metric_status_id = jvm.id),
    '[]'
  )::jsonb AS measurements
FROM
  job_verification_metric jvm
WHERE
  jvm.id = $1
`

type GetVerificationMetricWithMeasurementsRow struct {
	ID               uuid.UUID
	CreatedAt        pgtype.Timestamptz
	JobID            uuid.UUID
	Name             string
	Provider         []byte
	IntervalSeconds  int32
	Count            int32
	SuccessCondition string
	SuccessThreshold pgtype.Int4
	FailureCondition pgtype.Text
	FailureThreshold pgtype.Int4
	Measurements     []byte
}

func (q *Queries) GetVerificationMetricWithMeasurements(ctx context.Context, id uuid.UUID) (GetVerificationMetricWithMeasurementsRow, error) {
	row := q.db.QueryRow(ctx, getVerificationMetricWithMeasurements, id)
	var i GetVerificationMetricWithMeasurementsRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.JobID,
		&i.Name,
		&i.Provider,
		&i.IntervalSeconds,
		&i.Count,
		&i.SuccessCondition,
		&i.SuccessThreshold,
		&i.FailureCondition,
		&i.FailureThreshold,
		&i.Measurements,
	)
	return i, err
}

const insertJobVerificationMetric = `-- name: InsertJobVerificationMetric :one
INSERT INTO job_verification_metric (
  job_id, name, provider, interval_seconds, count,
  success_condition, success_threshold, failure_condition, failure_threshold
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, created_at, job_id, name, provider, interval_seconds, count, success_condition, success_threshold, failure_condition, failure_threshold
`

type InsertJobVerificationMetricParams struct {
	JobID            uuid.UUID
	Name             string
	Provider         []byte
	IntervalSeconds  int32
	Count            int32
	SuccessCondition string
	SuccessThreshold pgtype.Int4
	FailureCondition pgtype.Text
	FailureThreshold pgtype.Int4
}

func (q *Queries) InsertJobVerificationMetric(ctx context.Context, arg InsertJobVerificationMetricParams) (JobVerificationMetric, error) {
	row := q.db.QueryRow(ctx, insertJobVerificationMetric,
		arg.JobID,
		arg.Name,
		arg.Provider,
		arg.IntervalSeconds,
		arg.Count,
		arg.SuccessCondition,
		arg.SuccessThreshold,
		arg.FailureCondition,
		arg.FailureThreshold,
	)
	var i JobVerificationMetric
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.JobID,
		&i.Name,
		&i.Provider,
		&i.IntervalSeconds,
		&i.Count,
		&i.SuccessCondition,
		&i.SuccessThreshold,
		&i.FailureCondition,
		&i.FailureThreshold,
	)
	return i, err
}

const insertJobVerificationMetricMeasurement = `-- name: InsertJobVerificationMetricMeasurement :exec
INSERT INTO job_verification_metric_measurement (
  job_verification_metric_status_id, data, measured_at, message, status
) VALUES ($1, $2, $3, $4, $5)
`

type InsertJobVerificationMetricMeasurementParams struct {
	JobVerificationMetricStatusID uuid.UUID
	Data                          []byte
	MeasuredAt                    pgtype.Timestamptz
	Message                       string
	Status                        JobVerificationStatus
}

func (q *Queries) InsertJobVerificationMetricMeasurement(ctx context.Context, arg InsertJobVerificationMetricMeasurementParams) error {
	_, err := q.db.Exec(ctx, insertJobVerificationMetricMeasurement,
		arg.JobVerificationMetricStatusID,
		arg.Data,
		arg.MeasuredAt,
		arg.Message,
		arg.Status,
	)
	return err
}
