// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspace_engine.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDeploymentByID = `-- name: GetDeploymentByID :one
SELECT
    d.id,
    d.name,
    d.slug,
    d.description,
    d.system_id,
    d.job_agent_id,
    d.job_agent_config,
    d.retry_count,
    d.timeout,
    d.resource_selector
FROM deployment AS d
WHERE d.id = $1
LIMIT 1
`

func (q *Queries) GetDeploymentByID(ctx context.Context, id pgtype.UUID) (Deployment, error) {
	row := q.db.QueryRow(ctx, getDeploymentByID, id)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.SystemID,
		&i.JobAgentID,
		&i.JobAgentConfig,
		&i.RetryCount,
		&i.Timeout,
		&i.ResourceSelector,
	)
	return i, err
}

const getReleaseTargetID = `-- name: GetReleaseTargetID :one
SELECT
    rt.id
FROM release_target AS rt
WHERE rt.resource_id = $1
  AND rt.environment_id = $2
  AND rt.deployment_id = $3
LIMIT 1
`

type GetReleaseTargetIDParams struct {
	ResourceID    pgtype.UUID `json:"resource_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
	DeploymentID  pgtype.UUID `json:"deployment_id"`
}

func (q *Queries) GetReleaseTargetID(ctx context.Context, arg GetReleaseTargetIDParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getReleaseTargetID, arg.ResourceID, arg.EnvironmentID, arg.DeploymentID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertReleaseTargetIfMissing = `-- name: InsertReleaseTargetIfMissing :exec
INSERT INTO release_target (resource_id, environment_id, deployment_id)
VALUES ($1, $2, $3)
ON CONFLICT (resource_id, environment_id, deployment_id)
DO NOTHING
`

type InsertReleaseTargetIfMissingParams struct {
	ResourceID    pgtype.UUID `json:"resource_id"`
	EnvironmentID pgtype.UUID `json:"environment_id"`
	DeploymentID  pgtype.UUID `json:"deployment_id"`
}

func (q *Queries) InsertReleaseTargetIfMissing(ctx context.Context, arg InsertReleaseTargetIfMissingParams) error {
	_, err := q.db.Exec(ctx, insertReleaseTargetIfMissing, arg.ResourceID, arg.EnvironmentID, arg.DeploymentID)
	return err
}

const listDeploymentsByWorkspace = `-- name: ListDeploymentsByWorkspace :many
SELECT
    d.id,
    d.name,
    d.slug,
    d.description,
    d.system_id,
    d.job_agent_id,
    d.job_agent_config,
    d.retry_count,
    d.timeout,
    d.resource_selector
FROM deployment AS d
INNER JOIN system AS s
    ON s.id = d.system_id
WHERE s.workspace_id = $1
ORDER BY d.name ASC
`

func (q *Queries) ListDeploymentsByWorkspace(ctx context.Context, workspaceID pgtype.UUID) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, listDeploymentsByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.SystemID,
			&i.JobAgentID,
			&i.JobAgentConfig,
			&i.RetryCount,
			&i.Timeout,
			&i.ResourceSelector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironmentsByWorkspace = `-- name: ListEnvironmentsByWorkspace :many
SELECT
    e.id,
    e.name,
    e.system_id,
    e.created_at,
    e.description,
    e.resource_selector
FROM environment AS e
INNER JOIN system AS s
    ON s.id = e.system_id
WHERE s.workspace_id = $1
ORDER BY e.name ASC
`

type ListEnvironmentsByWorkspaceRow struct {
	ID               pgtype.UUID        `json:"id"`
	Name             string             `json:"name"`
	SystemID         pgtype.UUID        `json:"system_id"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	Description      pgtype.Text        `json:"description"`
	ResourceSelector []byte             `json:"resource_selector"`
}

func (q *Queries) ListEnvironmentsByWorkspace(ctx context.Context, workspaceID pgtype.UUID) ([]ListEnvironmentsByWorkspaceRow, error) {
	rows, err := q.db.Query(ctx, listEnvironmentsByWorkspace, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEnvironmentsByWorkspaceRow
	for rows.Next() {
		var i ListEnvironmentsByWorkspaceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SystemID,
			&i.CreatedAt,
			&i.Description,
			&i.ResourceSelector,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDeployment = `-- name: UpsertDeployment :one
INSERT INTO deployment (
    id,
    name,
    slug,
    description,
    system_id,
    job_agent_id,
    job_agent_config,
    retry_count,
    timeout,
    resource_selector
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
ON CONFLICT (id)
DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    description = EXCLUDED.description,
    system_id = EXCLUDED.system_id,
    job_agent_id = EXCLUDED.job_agent_id,
    job_agent_config = EXCLUDED.job_agent_config,
    retry_count = EXCLUDED.retry_count,
    timeout = EXCLUDED.timeout,
    resource_selector = EXCLUDED.resource_selector
RETURNING
    id,
    name,
    slug,
    description,
    system_id,
    job_agent_id,
    job_agent_config,
    retry_count,
    timeout,
    resource_selector
`

type UpsertDeploymentParams struct {
	ID               pgtype.UUID `json:"id"`
	Name             string      `json:"name"`
	Slug             string      `json:"slug"`
	Description      string      `json:"description"`
	SystemID         pgtype.UUID `json:"system_id"`
	JobAgentID       pgtype.UUID `json:"job_agent_id"`
	JobAgentConfig   []byte      `json:"job_agent_config"`
	RetryCount       int32       `json:"retry_count"`
	Timeout          pgtype.Int4 `json:"timeout"`
	ResourceSelector []byte      `json:"resource_selector"`
}

func (q *Queries) UpsertDeployment(ctx context.Context, arg UpsertDeploymentParams) (Deployment, error) {
	row := q.db.QueryRow(ctx, upsertDeployment,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.SystemID,
		arg.JobAgentID,
		arg.JobAgentConfig,
		arg.RetryCount,
		arg.Timeout,
		arg.ResourceSelector,
	)
	var i Deployment
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.SystemID,
		&i.JobAgentID,
		&i.JobAgentConfig,
		&i.RetryCount,
		&i.Timeout,
		&i.ResourceSelector,
	)
	return i, err
}
