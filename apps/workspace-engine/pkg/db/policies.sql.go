// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: policies.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAnyApprovalRulesByPolicyID = `-- name: DeleteAnyApprovalRulesByPolicyID :exec
DELETE FROM policy_rule_any_approval WHERE policy_id = $1
`

func (q *Queries) DeleteAnyApprovalRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAnyApprovalRulesByPolicyID, policyID)
	return err
}

const deleteDeploymentDependencyRulesByPolicyID = `-- name: DeleteDeploymentDependencyRulesByPolicyID :exec
DELETE FROM policy_rule_deployment_dependency WHERE policy_id = $1
`

func (q *Queries) DeleteDeploymentDependencyRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDeploymentDependencyRulesByPolicyID, policyID)
	return err
}

const deleteDeploymentWindowRulesByPolicyID = `-- name: DeleteDeploymentWindowRulesByPolicyID :exec
DELETE FROM policy_rule_deployment_window WHERE policy_id = $1
`

func (q *Queries) DeleteDeploymentWindowRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDeploymentWindowRulesByPolicyID, policyID)
	return err
}

const deleteEnvironmentProgressionRulesByPolicyID = `-- name: DeleteEnvironmentProgressionRulesByPolicyID :exec
DELETE FROM policy_rule_environment_progression WHERE policy_id = $1
`

func (q *Queries) DeleteEnvironmentProgressionRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEnvironmentProgressionRulesByPolicyID, policyID)
	return err
}

const deleteGradualRolloutRulesByPolicyID = `-- name: DeleteGradualRolloutRulesByPolicyID :exec
DELETE FROM policy_rule_gradual_rollout WHERE policy_id = $1
`

func (q *Queries) DeleteGradualRolloutRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteGradualRolloutRulesByPolicyID, policyID)
	return err
}

const deletePolicy = `-- name: DeletePolicy :exec
DELETE FROM policy WHERE id = $1
`

func (q *Queries) DeletePolicy(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePolicy, id)
	return err
}

const deleteRetryRulesByPolicyID = `-- name: DeleteRetryRulesByPolicyID :exec
DELETE FROM policy_rule_retry WHERE policy_id = $1
`

func (q *Queries) DeleteRetryRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRetryRulesByPolicyID, policyID)
	return err
}

const deleteRollbackRulesByPolicyID = `-- name: DeleteRollbackRulesByPolicyID :exec
DELETE FROM policy_rule_rollback WHERE policy_id = $1
`

func (q *Queries) DeleteRollbackRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRollbackRulesByPolicyID, policyID)
	return err
}

const deleteVerificationRulesByPolicyID = `-- name: DeleteVerificationRulesByPolicyID :exec
DELETE FROM policy_rule_verification WHERE policy_id = $1
`

func (q *Queries) DeleteVerificationRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVerificationRulesByPolicyID, policyID)
	return err
}

const deleteVersionCooldownRulesByPolicyID = `-- name: DeleteVersionCooldownRulesByPolicyID :exec
DELETE FROM policy_rule_version_cooldown WHERE policy_id = $1
`

func (q *Queries) DeleteVersionCooldownRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVersionCooldownRulesByPolicyID, policyID)
	return err
}

const deleteVersionSelectorRulesByPolicyID = `-- name: DeleteVersionSelectorRulesByPolicyID :exec
DELETE FROM policy_rule_version_selector WHERE policy_id = $1
`

func (q *Queries) DeleteVersionSelectorRulesByPolicyID(ctx context.Context, policyID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVersionSelectorRulesByPolicyID, policyID)
	return err
}

const getPolicyByID = `-- name: GetPolicyByID :one
SELECT id, name, description, selector, metadata, priority, enabled, workspace_id, created_at
FROM policy
WHERE id = $1
`

func (q *Queries) GetPolicyByID(ctx context.Context, id uuid.UUID) (Policy, error) {
	row := q.db.QueryRow(ctx, getPolicyByID, id)
	var i Policy
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Selector,
		&i.Metadata,
		&i.Priority,
		&i.Enabled,
		&i.WorkspaceID,
		&i.CreatedAt,
	)
	return i, err
}

const listAnyApprovalRulesByPolicyID = `-- name: ListAnyApprovalRulesByPolicyID :many

SELECT id, policy_id, min_approvals, created_at
FROM policy_rule_any_approval
WHERE policy_id = $1
`

// ============================================================
// policy_rule_any_approval
// ============================================================
func (q *Queries) ListAnyApprovalRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleAnyApproval, error) {
	rows, err := q.db.Query(ctx, listAnyApprovalRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleAnyApproval
	for rows.Next() {
		var i PolicyRuleAnyApproval
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.MinApprovals,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentDependencyRulesByPolicyID = `-- name: ListDeploymentDependencyRulesByPolicyID :many

SELECT id, policy_id, depends_on, created_at
FROM policy_rule_deployment_dependency
WHERE policy_id = $1
`

// ============================================================
// policy_rule_deployment_dependency
// ============================================================
func (q *Queries) ListDeploymentDependencyRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleDeploymentDependency, error) {
	rows, err := q.db.Query(ctx, listDeploymentDependencyRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleDeploymentDependency
	for rows.Next() {
		var i PolicyRuleDeploymentDependency
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.DependsOn,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeploymentWindowRulesByPolicyID = `-- name: ListDeploymentWindowRulesByPolicyID :many

SELECT id, policy_id, allow_window, duration_minutes, rrule, timezone, created_at
FROM policy_rule_deployment_window
WHERE policy_id = $1
`

// ============================================================
// policy_rule_deployment_window
// ============================================================
func (q *Queries) ListDeploymentWindowRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleDeploymentWindow, error) {
	rows, err := q.db.Query(ctx, listDeploymentWindowRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleDeploymentWindow
	for rows.Next() {
		var i PolicyRuleDeploymentWindow
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.AllowWindow,
			&i.DurationMinutes,
			&i.Rrule,
			&i.Timezone,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvironmentProgressionRulesByPolicyID = `-- name: ListEnvironmentProgressionRulesByPolicyID :many

SELECT id, policy_id, depends_on_environment_selector, maximum_age_hours,
       minimum_soak_time_minutes, minimum_success_percentage, success_statuses, created_at
FROM policy_rule_environment_progression
WHERE policy_id = $1
`

// ============================================================
// policy_rule_environment_progression
// ============================================================
func (q *Queries) ListEnvironmentProgressionRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleEnvironmentProgression, error) {
	rows, err := q.db.Query(ctx, listEnvironmentProgressionRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleEnvironmentProgression
	for rows.Next() {
		var i PolicyRuleEnvironmentProgression
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.DependsOnEnvironmentSelector,
			&i.MaximumAgeHours,
			&i.MinimumSoakTimeMinutes,
			&i.MinimumSuccessPercentage,
			&i.SuccessStatuses,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGradualRolloutRulesByPolicyID = `-- name: ListGradualRolloutRulesByPolicyID :many

SELECT id, policy_id, rollout_type, time_scale_interval, created_at
FROM policy_rule_gradual_rollout
WHERE policy_id = $1
`

// ============================================================
// policy_rule_gradual_rollout
// ============================================================
func (q *Queries) ListGradualRolloutRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleGradualRollout, error) {
	rows, err := q.db.Query(ctx, listGradualRolloutRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleGradualRollout
	for rows.Next() {
		var i PolicyRuleGradualRollout
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.RolloutType,
			&i.TimeScaleInterval,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPoliciesByWorkspaceID = `-- name: ListPoliciesByWorkspaceID :many
SELECT id, name, description, selector, metadata, priority, enabled, workspace_id, created_at
FROM policy
WHERE workspace_id = $1
ORDER BY priority DESC, created_at DESC
LIMIT COALESCE($2::int, 5000)
`

type ListPoliciesByWorkspaceIDParams struct {
	WorkspaceID uuid.UUID
	Limit       pgtype.Int4
}

func (q *Queries) ListPoliciesByWorkspaceID(ctx context.Context, arg ListPoliciesByWorkspaceIDParams) ([]Policy, error) {
	rows, err := q.db.Query(ctx, listPoliciesByWorkspaceID, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Policy
	for rows.Next() {
		var i Policy
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Selector,
			&i.Metadata,
			&i.Priority,
			&i.Enabled,
			&i.WorkspaceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRetryRulesByPolicyID = `-- name: ListRetryRulesByPolicyID :many

SELECT id, policy_id, max_retries, backoff_seconds, backoff_strategy,
       max_backoff_seconds, retry_on_statuses, created_at
FROM policy_rule_retry
WHERE policy_id = $1
`

// ============================================================
// policy_rule_retry
// ============================================================
func (q *Queries) ListRetryRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleRetry, error) {
	rows, err := q.db.Query(ctx, listRetryRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleRetry
	for rows.Next() {
		var i PolicyRuleRetry
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.MaxRetries,
			&i.BackoffSeconds,
			&i.BackoffStrategy,
			&i.MaxBackoffSeconds,
			&i.RetryOnStatuses,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRollbackRulesByPolicyID = `-- name: ListRollbackRulesByPolicyID :many

SELECT id, policy_id, on_job_statuses, on_verification_failure, created_at
FROM policy_rule_rollback
WHERE policy_id = $1
`

// ============================================================
// policy_rule_rollback
// ============================================================
func (q *Queries) ListRollbackRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleRollback, error) {
	rows, err := q.db.Query(ctx, listRollbackRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleRollback
	for rows.Next() {
		var i PolicyRuleRollback
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.OnJobStatuses,
			&i.OnVerificationFailure,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationRulesByPolicyID = `-- name: ListVerificationRulesByPolicyID :many

SELECT id, policy_id, metrics, trigger_on, created_at
FROM policy_rule_verification
WHERE policy_id = $1
`

// ============================================================
// policy_rule_verification
// ============================================================
func (q *Queries) ListVerificationRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleVerification, error) {
	rows, err := q.db.Query(ctx, listVerificationRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleVerification
	for rows.Next() {
		var i PolicyRuleVerification
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.Metrics,
			&i.TriggerOn,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVersionCooldownRulesByPolicyID = `-- name: ListVersionCooldownRulesByPolicyID :many

SELECT id, policy_id, interval_seconds, created_at
FROM policy_rule_version_cooldown
WHERE policy_id = $1
`

// ============================================================
// policy_rule_version_cooldown
// ============================================================
func (q *Queries) ListVersionCooldownRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleVersionCooldown, error) {
	rows, err := q.db.Query(ctx, listVersionCooldownRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleVersionCooldown
	for rows.Next() {
		var i PolicyRuleVersionCooldown
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.IntervalSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVersionSelectorRulesByPolicyID = `-- name: ListVersionSelectorRulesByPolicyID :many

SELECT id, policy_id, description, selector, created_at
FROM policy_rule_version_selector
WHERE policy_id = $1
`

// ============================================================
// policy_rule_version_selector
// ============================================================
func (q *Queries) ListVersionSelectorRulesByPolicyID(ctx context.Context, policyID uuid.UUID) ([]PolicyRuleVersionSelector, error) {
	rows, err := q.db.Query(ctx, listVersionSelectorRulesByPolicyID, policyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PolicyRuleVersionSelector
	for rows.Next() {
		var i PolicyRuleVersionSelector
		if err := rows.Scan(
			&i.ID,
			&i.PolicyID,
			&i.Description,
			&i.Selector,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAnyApprovalRule = `-- name: UpsertAnyApprovalRule :exec
INSERT INTO policy_rule_any_approval (id, policy_id, min_approvals, created_at)
VALUES ($1, $2, $3, COALESCE($4::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET min_approvals = EXCLUDED.min_approvals
`

type UpsertAnyApprovalRuleParams struct {
	ID           uuid.UUID
	PolicyID     uuid.UUID
	MinApprovals int32
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) UpsertAnyApprovalRule(ctx context.Context, arg UpsertAnyApprovalRuleParams) error {
	_, err := q.db.Exec(ctx, upsertAnyApprovalRule,
		arg.ID,
		arg.PolicyID,
		arg.MinApprovals,
		arg.CreatedAt,
	)
	return err
}

const upsertDeploymentDependencyRule = `-- name: UpsertDeploymentDependencyRule :exec
INSERT INTO policy_rule_deployment_dependency (id, policy_id, depends_on, created_at)
VALUES ($1, $2, $3, COALESCE($4::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET depends_on = EXCLUDED.depends_on
`

type UpsertDeploymentDependencyRuleParams struct {
	ID        uuid.UUID
	PolicyID  uuid.UUID
	DependsOn string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) UpsertDeploymentDependencyRule(ctx context.Context, arg UpsertDeploymentDependencyRuleParams) error {
	_, err := q.db.Exec(ctx, upsertDeploymentDependencyRule,
		arg.ID,
		arg.PolicyID,
		arg.DependsOn,
		arg.CreatedAt,
	)
	return err
}

const upsertDeploymentWindowRule = `-- name: UpsertDeploymentWindowRule :exec
INSERT INTO policy_rule_deployment_window (id, policy_id, allow_window, duration_minutes, rrule, timezone, created_at)
VALUES ($1, $2, $3, $4, $5, $6, COALESCE($7::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET allow_window = EXCLUDED.allow_window, duration_minutes = EXCLUDED.duration_minutes,
    rrule = EXCLUDED.rrule, timezone = EXCLUDED.timezone
`

type UpsertDeploymentWindowRuleParams struct {
	ID              uuid.UUID
	PolicyID        uuid.UUID
	AllowWindow     pgtype.Bool
	DurationMinutes int32
	Rrule           string
	Timezone        pgtype.Text
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) UpsertDeploymentWindowRule(ctx context.Context, arg UpsertDeploymentWindowRuleParams) error {
	_, err := q.db.Exec(ctx, upsertDeploymentWindowRule,
		arg.ID,
		arg.PolicyID,
		arg.AllowWindow,
		arg.DurationMinutes,
		arg.Rrule,
		arg.Timezone,
		arg.CreatedAt,
	)
	return err
}

const upsertEnvironmentProgressionRule = `-- name: UpsertEnvironmentProgressionRule :exec
INSERT INTO policy_rule_environment_progression (
    id, policy_id, depends_on_environment_selector, maximum_age_hours,
    minimum_soak_time_minutes, minimum_success_percentage, success_statuses, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, COALESCE($8::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET depends_on_environment_selector = EXCLUDED.depends_on_environment_selector,
    maximum_age_hours = EXCLUDED.maximum_age_hours,
    minimum_soak_time_minutes = EXCLUDED.minimum_soak_time_minutes,
    minimum_success_percentage = EXCLUDED.minimum_success_percentage,
    success_statuses = EXCLUDED.success_statuses
`

type UpsertEnvironmentProgressionRuleParams struct {
	ID                           uuid.UUID
	PolicyID                     uuid.UUID
	DependsOnEnvironmentSelector string
	MaximumAgeHours              pgtype.Int4
	MinimumSoakTimeMinutes       pgtype.Int4
	MinimumSuccessPercentage     pgtype.Float4
	SuccessStatuses              []string
	CreatedAt                    pgtype.Timestamptz
}

func (q *Queries) UpsertEnvironmentProgressionRule(ctx context.Context, arg UpsertEnvironmentProgressionRuleParams) error {
	_, err := q.db.Exec(ctx, upsertEnvironmentProgressionRule,
		arg.ID,
		arg.PolicyID,
		arg.DependsOnEnvironmentSelector,
		arg.MaximumAgeHours,
		arg.MinimumSoakTimeMinutes,
		arg.MinimumSuccessPercentage,
		arg.SuccessStatuses,
		arg.CreatedAt,
	)
	return err
}

const upsertGradualRolloutRule = `-- name: UpsertGradualRolloutRule :exec
INSERT INTO policy_rule_gradual_rollout (id, policy_id, rollout_type, time_scale_interval, created_at)
VALUES ($1, $2, $3, $4, COALESCE($5::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET rollout_type = EXCLUDED.rollout_type, time_scale_interval = EXCLUDED.time_scale_interval
`

type UpsertGradualRolloutRuleParams struct {
	ID                uuid.UUID
	PolicyID          uuid.UUID
	RolloutType       string
	TimeScaleInterval int32
	CreatedAt         pgtype.Timestamptz
}

func (q *Queries) UpsertGradualRolloutRule(ctx context.Context, arg UpsertGradualRolloutRuleParams) error {
	_, err := q.db.Exec(ctx, upsertGradualRolloutRule,
		arg.ID,
		arg.PolicyID,
		arg.RolloutType,
		arg.TimeScaleInterval,
		arg.CreatedAt,
	)
	return err
}

const upsertPolicy = `-- name: UpsertPolicy :one
INSERT INTO policy (id, name, description, selector, metadata, priority, enabled, workspace_id, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name, description = EXCLUDED.description,
    selector = EXCLUDED.selector, metadata = EXCLUDED.metadata,
    priority = EXCLUDED.priority, enabled = EXCLUDED.enabled,
    workspace_id = EXCLUDED.workspace_id,
    created_at = CASE WHEN $9::timestamptz IS NOT NULL THEN EXCLUDED.created_at ELSE policy.created_at END
RETURNING id, name, description, selector, metadata, priority, enabled, workspace_id, created_at
`

type UpsertPolicyParams struct {
	ID          uuid.UUID
	Name        string
	Description pgtype.Text
	Selector    string
	Metadata    map[string]string
	Priority    int32
	Enabled     bool
	WorkspaceID uuid.UUID
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) UpsertPolicy(ctx context.Context, arg UpsertPolicyParams) (Policy, error) {
	row := q.db.QueryRow(ctx, upsertPolicy,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Selector,
		arg.Metadata,
		arg.Priority,
		arg.Enabled,
		arg.WorkspaceID,
		arg.CreatedAt,
	)
	var i Policy
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Selector,
		&i.Metadata,
		&i.Priority,
		&i.Enabled,
		&i.WorkspaceID,
		&i.CreatedAt,
	)
	return i, err
}

const upsertRetryRule = `-- name: UpsertRetryRule :exec
INSERT INTO policy_rule_retry (
    id, policy_id, max_retries, backoff_seconds, backoff_strategy,
    max_backoff_seconds, retry_on_statuses, created_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, COALESCE($8::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET max_retries = EXCLUDED.max_retries, backoff_seconds = EXCLUDED.backoff_seconds,
    backoff_strategy = EXCLUDED.backoff_strategy, max_backoff_seconds = EXCLUDED.max_backoff_seconds,
    retry_on_statuses = EXCLUDED.retry_on_statuses
`

type UpsertRetryRuleParams struct {
	ID                uuid.UUID
	PolicyID          uuid.UUID
	MaxRetries        int32
	BackoffSeconds    pgtype.Int4
	BackoffStrategy   pgtype.Text
	MaxBackoffSeconds pgtype.Int4
	RetryOnStatuses   []string
	CreatedAt         pgtype.Timestamptz
}

func (q *Queries) UpsertRetryRule(ctx context.Context, arg UpsertRetryRuleParams) error {
	_, err := q.db.Exec(ctx, upsertRetryRule,
		arg.ID,
		arg.PolicyID,
		arg.MaxRetries,
		arg.BackoffSeconds,
		arg.BackoffStrategy,
		arg.MaxBackoffSeconds,
		arg.RetryOnStatuses,
		arg.CreatedAt,
	)
	return err
}

const upsertRollbackRule = `-- name: UpsertRollbackRule :exec
INSERT INTO policy_rule_rollback (id, policy_id, on_job_statuses, on_verification_failure, created_at)
VALUES ($1, $2, $3, $4, COALESCE($5::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET on_job_statuses = EXCLUDED.on_job_statuses, on_verification_failure = EXCLUDED.on_verification_failure
`

type UpsertRollbackRuleParams struct {
	ID                    uuid.UUID
	PolicyID              uuid.UUID
	OnJobStatuses         []string
	OnVerificationFailure pgtype.Bool
	CreatedAt             pgtype.Timestamptz
}

func (q *Queries) UpsertRollbackRule(ctx context.Context, arg UpsertRollbackRuleParams) error {
	_, err := q.db.Exec(ctx, upsertRollbackRule,
		arg.ID,
		arg.PolicyID,
		arg.OnJobStatuses,
		arg.OnVerificationFailure,
		arg.CreatedAt,
	)
	return err
}

const upsertVerificationRule = `-- name: UpsertVerificationRule :exec
INSERT INTO policy_rule_verification (id, policy_id, metrics, trigger_on, created_at)
VALUES ($1, $2, $3, $4, COALESCE($5::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET metrics = EXCLUDED.metrics, trigger_on = EXCLUDED.trigger_on
`

type UpsertVerificationRuleParams struct {
	ID        uuid.UUID
	PolicyID  uuid.UUID
	Metrics   []byte
	TriggerOn pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) UpsertVerificationRule(ctx context.Context, arg UpsertVerificationRuleParams) error {
	_, err := q.db.Exec(ctx, upsertVerificationRule,
		arg.ID,
		arg.PolicyID,
		arg.Metrics,
		arg.TriggerOn,
		arg.CreatedAt,
	)
	return err
}

const upsertVersionCooldownRule = `-- name: UpsertVersionCooldownRule :exec
INSERT INTO policy_rule_version_cooldown (id, policy_id, interval_seconds, created_at)
VALUES ($1, $2, $3, COALESCE($4::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET interval_seconds = EXCLUDED.interval_seconds
`

type UpsertVersionCooldownRuleParams struct {
	ID              uuid.UUID
	PolicyID        uuid.UUID
	IntervalSeconds int32
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) UpsertVersionCooldownRule(ctx context.Context, arg UpsertVersionCooldownRuleParams) error {
	_, err := q.db.Exec(ctx, upsertVersionCooldownRule,
		arg.ID,
		arg.PolicyID,
		arg.IntervalSeconds,
		arg.CreatedAt,
	)
	return err
}

const upsertVersionSelectorRule = `-- name: UpsertVersionSelectorRule :exec
INSERT INTO policy_rule_version_selector (id, policy_id, description, selector, created_at)
VALUES ($1, $2, $3, $4, COALESCE($5::timestamptz, NOW()))
ON CONFLICT (id) DO UPDATE
SET description = EXCLUDED.description, selector = EXCLUDED.selector
`

type UpsertVersionSelectorRuleParams struct {
	ID          uuid.UUID
	PolicyID    uuid.UUID
	Description pgtype.Text
	Selector    string
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) UpsertVersionSelectorRule(ctx context.Context, arg UpsertVersionSelectorRuleParams) error {
	_, err := q.db.Exec(ctx, upsertVersionSelectorRule,
		arg.ID,
		arg.PolicyID,
		arg.Description,
		arg.Selector,
		arg.CreatedAt,
	)
	return err
}

const listPoliciesWithRulesByWorkspaceID = `-- name: ListPoliciesWithRulesByWorkspaceID :many
SELECT
  p.id, p.name, p.description, p.selector, p.metadata, p.priority, p.enabled, p.workspace_id, p.created_at,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'min_approvals', r.min_approvals, 'created_at', r.created_at))
    FROM policy_rule_any_approval r WHERE r.policy_id = p.id), '[]')::jsonb AS any_approval_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'depends_on', r.depends_on, 'created_at', r.created_at))
    FROM policy_rule_deployment_dependency r WHERE r.policy_id = p.id), '[]')::jsonb AS deployment_dependency_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'allow_window', r.allow_window, 'duration_minutes', r.duration_minutes, 'rrule', r.rrule, 'timezone', r.timezone, 'created_at', r.created_at))
    FROM policy_rule_deployment_window r WHERE r.policy_id = p.id), '[]')::jsonb AS deployment_window_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'depends_on_environment_selector', r.depends_on_environment_selector, 'maximum_age_hours', r.maximum_age_hours, 'minimum_soak_time_minutes', r.minimum_soak_time_minutes, 'minimum_success_percentage', r.minimum_success_percentage, 'success_statuses', r.success_statuses, 'created_at', r.created_at))
    FROM policy_rule_environment_progression r WHERE r.policy_id = p.id), '[]')::jsonb AS environment_progression_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'rollout_type', r.rollout_type, 'time_scale_interval', r.time_scale_interval, 'created_at', r.created_at))
    FROM policy_rule_gradual_rollout r WHERE r.policy_id = p.id), '[]')::jsonb AS gradual_rollout_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'max_retries', r.max_retries, 'backoff_seconds', r.backoff_seconds, 'backoff_strategy', r.backoff_strategy, 'max_backoff_seconds', r.max_backoff_seconds, 'retry_on_statuses', r.retry_on_statuses, 'created_at', r.created_at))
    FROM policy_rule_retry r WHERE r.policy_id = p.id), '[]')::jsonb AS retry_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'on_job_statuses', r.on_job_statuses, 'on_verification_failure', r.on_verification_failure, 'created_at', r.created_at))
    FROM policy_rule_rollback r WHERE r.policy_id = p.id), '[]')::jsonb AS rollback_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'metrics', r.metrics, 'trigger_on', r.trigger_on, 'created_at', r.created_at))
    FROM policy_rule_verification r WHERE r.policy_id = p.id), '[]')::jsonb AS verification_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'interval_seconds', r.interval_seconds, 'created_at', r.created_at))
    FROM policy_rule_version_cooldown r WHERE r.policy_id = p.id), '[]')::jsonb AS version_cooldown_rules,
  COALESCE((SELECT json_agg(json_build_object('id', r.id, 'policy_id', r.policy_id, 'description', r.description, 'selector', r.selector, 'created_at', r.created_at))
    FROM policy_rule_version_selector r WHERE r.policy_id = p.id), '[]')::jsonb AS version_selector_rules
FROM policy p
WHERE p.workspace_id = $1
ORDER BY p.priority DESC, p.created_at DESC
`

type ListPoliciesWithRulesByWorkspaceIDRow struct {
	ID                         uuid.UUID
	Name                       string
	Description                pgtype.Text
	Selector                   string
	Metadata                   map[string]string
	Priority                   int32
	Enabled                    bool
	WorkspaceID                uuid.UUID
	CreatedAt                  pgtype.Timestamptz
	AnyApprovalRules           []byte
	DeploymentDependencyRules  []byte
	DeploymentWindowRules      []byte
	EnvironmentProgressionRules []byte
	GradualRolloutRules        []byte
	RetryRules                 []byte
	RollbackRules              []byte
	VerificationRules          []byte
	VersionCooldownRules       []byte
	VersionSelectorRules       []byte
}

func (q *Queries) ListPoliciesWithRulesByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]ListPoliciesWithRulesByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, listPoliciesWithRulesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPoliciesWithRulesByWorkspaceIDRow
	for rows.Next() {
		var i ListPoliciesWithRulesByWorkspaceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Selector,
			&i.Metadata,
			&i.Priority,
			&i.Enabled,
			&i.WorkspaceID,
			&i.CreatedAt,
			&i.AnyApprovalRules,
			&i.DeploymentDependencyRules,
			&i.DeploymentWindowRules,
			&i.EnvironmentProgressionRules,
			&i.GradualRolloutRules,
			&i.RetryRules,
			&i.RollbackRules,
			&i.VerificationRules,
			&i.VersionCooldownRules,
			&i.VersionSelectorRules,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
