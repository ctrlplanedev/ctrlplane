// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workflows.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteWorkflow = `-- name: DeleteWorkflow :exec
DELETE FROM workflow WHERE id = $1
`

func (q *Queries) DeleteWorkflow(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkflow, id)
	return err
}

const deleteWorkflowJob = `-- name: DeleteWorkflowJob :exec
DELETE FROM workflow_job WHERE id = $1
`

func (q *Queries) DeleteWorkflowJob(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkflowJob, id)
	return err
}

const deleteWorkflowJobTemplate = `-- name: DeleteWorkflowJobTemplate :exec
DELETE FROM workflow_job_template WHERE id = $1
`

func (q *Queries) DeleteWorkflowJobTemplate(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkflowJobTemplate, id)
	return err
}

const deleteWorkflowRun = `-- name: DeleteWorkflowRun :exec
DELETE FROM workflow_run WHERE id = $1
`

func (q *Queries) DeleteWorkflowRun(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkflowRun, id)
	return err
}

const getWorkflowByID = `-- name: GetWorkflowByID :one
SELECT id, name, inputs, jobs, workspace_id FROM workflow WHERE id = $1
`

func (q *Queries) GetWorkflowByID(ctx context.Context, id uuid.UUID) (Workflow, error) {
	row := q.db.QueryRow(ctx, getWorkflowByID, id)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Inputs,
		&i.Jobs,
		&i.WorkspaceID,
	)
	return i, err
}

const getWorkflowJobByID = `-- name: GetWorkflowJobByID :one
SELECT id, workflow_run_id, ref, config, index FROM workflow_job WHERE id = $1
`

func (q *Queries) GetWorkflowJobByID(ctx context.Context, id uuid.UUID) (WorkflowJob, error) {
	row := q.db.QueryRow(ctx, getWorkflowJobByID, id)
	var i WorkflowJob
	err := row.Scan(
		&i.ID,
		&i.WorkflowRunID,
		&i.Ref,
		&i.Config,
		&i.Index,
	)
	return i, err
}

const getWorkflowJobTemplateByID = `-- name: GetWorkflowJobTemplateByID :one
SELECT id, name, ref, config, if_condition, matrix, workspace_id FROM workflow_job_template WHERE id = $1
`

func (q *Queries) GetWorkflowJobTemplateByID(ctx context.Context, id uuid.UUID) (WorkflowJobTemplate, error) {
	row := q.db.QueryRow(ctx, getWorkflowJobTemplateByID, id)
	var i WorkflowJobTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ref,
		&i.Config,
		&i.IfCondition,
		&i.Matrix,
		&i.WorkspaceID,
	)
	return i, err
}

const getWorkflowRunByID = `-- name: GetWorkflowRunByID :one
SELECT id, workflow_id, inputs FROM workflow_run WHERE id = $1
`

func (q *Queries) GetWorkflowRunByID(ctx context.Context, id uuid.UUID) (WorkflowRun, error) {
	row := q.db.QueryRow(ctx, getWorkflowRunByID, id)
	var i WorkflowRun
	err := row.Scan(&i.ID, &i.WorkflowID, &i.Inputs)
	return i, err
}

const listWorkflowJobTemplatesByWorkspaceID = `-- name: ListWorkflowJobTemplatesByWorkspaceID :many
SELECT id, name, ref, config, if_condition, matrix, workspace_id FROM workflow_job_template WHERE workspace_id = $1
`

func (q *Queries) ListWorkflowJobTemplatesByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]WorkflowJobTemplate, error) {
	rows, err := q.db.Query(ctx, listWorkflowJobTemplatesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowJobTemplate
	for rows.Next() {
		var i WorkflowJobTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ref,
			&i.Config,
			&i.IfCondition,
			&i.Matrix,
			&i.WorkspaceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowJobsByWorkflowRunID = `-- name: ListWorkflowJobsByWorkflowRunID :many
SELECT id, workflow_run_id, ref, config, index FROM workflow_job WHERE workflow_run_id = $1 ORDER BY index ASC
`

func (q *Queries) ListWorkflowJobsByWorkflowRunID(ctx context.Context, workflowRunID uuid.UUID) ([]WorkflowJob, error) {
	rows, err := q.db.Query(ctx, listWorkflowJobsByWorkflowRunID, workflowRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowJob
	for rows.Next() {
		var i WorkflowJob
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowRunID,
			&i.Ref,
			&i.Config,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowJobsByWorkspaceID = `-- name: ListWorkflowJobsByWorkspaceID :many
SELECT wj.id, wj.workflow_run_id, wj.ref, wj.config, wj.index
FROM workflow_job wj
INNER JOIN workflow_run wr ON wr.id = wj.workflow_run_id
INNER JOIN workflow w ON w.id = wr.workflow_id
WHERE w.workspace_id = $1
ORDER BY wj.index ASC
`

func (q *Queries) ListWorkflowJobsByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]WorkflowJob, error) {
	rows, err := q.db.Query(ctx, listWorkflowJobsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowJob
	for rows.Next() {
		var i WorkflowJob
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowRunID,
			&i.Ref,
			&i.Config,
			&i.Index,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowRunsByWorkflowID = `-- name: ListWorkflowRunsByWorkflowID :many
SELECT id, workflow_id, inputs FROM workflow_run WHERE workflow_id = $1
`

func (q *Queries) ListWorkflowRunsByWorkflowID(ctx context.Context, workflowID uuid.UUID) ([]WorkflowRun, error) {
	rows, err := q.db.Query(ctx, listWorkflowRunsByWorkflowID, workflowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowRun
	for rows.Next() {
		var i WorkflowRun
		if err := rows.Scan(&i.ID, &i.WorkflowID, &i.Inputs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowRunsByWorkspaceID = `-- name: ListWorkflowRunsByWorkspaceID :many
SELECT wr.id, wr.workflow_id, wr.inputs
FROM workflow_run wr
INNER JOIN workflow w ON w.id = wr.workflow_id
WHERE w.workspace_id = $1
`

func (q *Queries) ListWorkflowRunsByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]WorkflowRun, error) {
	rows, err := q.db.Query(ctx, listWorkflowRunsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowRun
	for rows.Next() {
		var i WorkflowRun
		if err := rows.Scan(&i.ID, &i.WorkflowID, &i.Inputs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowsByWorkspaceID = `-- name: ListWorkflowsByWorkspaceID :many
SELECT id, name, inputs, jobs, workspace_id FROM workflow WHERE workspace_id = $1
`

func (q *Queries) ListWorkflowsByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]Workflow, error) {
	rows, err := q.db.Query(ctx, listWorkflowsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workflow
	for rows.Next() {
		var i Workflow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Inputs,
			&i.Jobs,
			&i.WorkspaceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWorkflow = `-- name: UpsertWorkflow :one
INSERT INTO workflow (id, name, inputs, jobs, workspace_id) VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, inputs = EXCLUDED.inputs, jobs = EXCLUDED.jobs, workspace_id = EXCLUDED.workspace_id
RETURNING id, name, inputs, jobs, workspace_id
`

type UpsertWorkflowParams struct {
	ID          uuid.UUID
	Name        string
	Inputs      []byte
	Jobs        []byte
	WorkspaceID uuid.UUID
}

func (q *Queries) UpsertWorkflow(ctx context.Context, arg UpsertWorkflowParams) (Workflow, error) {
	row := q.db.QueryRow(ctx, upsertWorkflow,
		arg.ID,
		arg.Name,
		arg.Inputs,
		arg.Jobs,
		arg.WorkspaceID,
	)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Inputs,
		&i.Jobs,
		&i.WorkspaceID,
	)
	return i, err
}

const upsertWorkflowJob = `-- name: UpsertWorkflowJob :one
INSERT INTO workflow_job (id, workflow_run_id, ref, config, index) VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET workflow_run_id = EXCLUDED.workflow_run_id, ref = EXCLUDED.ref, config = EXCLUDED.config, index = EXCLUDED.index
RETURNING id, workflow_run_id, ref, config, index
`

type UpsertWorkflowJobParams struct {
	ID            uuid.UUID
	WorkflowRunID uuid.UUID
	Ref           string
	Config        map[string]any
	Index         int32
}

func (q *Queries) UpsertWorkflowJob(ctx context.Context, arg UpsertWorkflowJobParams) (WorkflowJob, error) {
	row := q.db.QueryRow(ctx, upsertWorkflowJob,
		arg.ID,
		arg.WorkflowRunID,
		arg.Ref,
		arg.Config,
		arg.Index,
	)
	var i WorkflowJob
	err := row.Scan(
		&i.ID,
		&i.WorkflowRunID,
		&i.Ref,
		&i.Config,
		&i.Index,
	)
	return i, err
}

const upsertWorkflowJobTemplate = `-- name: UpsertWorkflowJobTemplate :one
INSERT INTO workflow_job_template (id, name, ref, config, if_condition, matrix, workspace_id) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, ref = EXCLUDED.ref, config = EXCLUDED.config, if_condition = EXCLUDED.if_condition, matrix = EXCLUDED.matrix, workspace_id = EXCLUDED.workspace_id
RETURNING id, name, ref, config, if_condition, matrix, workspace_id
`

type UpsertWorkflowJobTemplateParams struct {
	ID          uuid.UUID
	Name        string
	Ref         string
	Config      map[string]any
	IfCondition pgtype.Text
	Matrix      []byte
	WorkspaceID uuid.UUID
}

func (q *Queries) UpsertWorkflowJobTemplate(ctx context.Context, arg UpsertWorkflowJobTemplateParams) (WorkflowJobTemplate, error) {
	row := q.db.QueryRow(ctx, upsertWorkflowJobTemplate,
		arg.ID,
		arg.Name,
		arg.Ref,
		arg.Config,
		arg.IfCondition,
		arg.Matrix,
		arg.WorkspaceID,
	)
	var i WorkflowJobTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ref,
		&i.Config,
		&i.IfCondition,
		&i.Matrix,
		&i.WorkspaceID,
	)
	return i, err
}

const upsertWorkflowRun = `-- name: UpsertWorkflowRun :one
INSERT INTO workflow_run (id, workflow_id, inputs) VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE SET workflow_id = EXCLUDED.workflow_id, inputs = EXCLUDED.inputs
RETURNING id, workflow_id, inputs
`

type UpsertWorkflowRunParams struct {
	ID         uuid.UUID
	WorkflowID uuid.UUID
	Inputs     map[string]any
}

func (q *Queries) UpsertWorkflowRun(ctx context.Context, arg UpsertWorkflowRunParams) (WorkflowRun, error) {
	row := q.db.QueryRow(ctx, upsertWorkflowRun, arg.ID, arg.WorkflowID, arg.Inputs)
	var i WorkflowRun
	err := row.Scan(&i.ID, &i.WorkflowID, &i.Inputs)
	return i, err
}
