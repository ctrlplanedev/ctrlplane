// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: resources.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteResource = `-- name: DeleteResource :exec
DELETE FROM resource WHERE id = $1
`

func (q *Queries) DeleteResource(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteResource, id)
	return err
}

const getResourceByID = `-- name: GetResourceByID :one
SELECT id, version, name, kind, identifier, provider_id, workspace_id,
       config, created_at, updated_at, deleted_at, metadata
FROM resource
WHERE id = $1
`

type GetResourceByIDRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

func (q *Queries) GetResourceByID(ctx context.Context, id uuid.UUID) (GetResourceByIDRow, error) {
	row := q.db.QueryRow(ctx, getResourceByID, id)
	var i GetResourceByIDRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Name,
		&i.Kind,
		&i.Identifier,
		&i.ProviderID,
		&i.WorkspaceID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Metadata,
	)
	return i, err
}

const getResourceByIdentifier = `-- name: GetResourceByIdentifier :one
SELECT id, version, name, kind, identifier, provider_id, workspace_id,
       config, created_at, updated_at, deleted_at, metadata
FROM resource
WHERE workspace_id = $1 AND identifier = $2
LIMIT 1
`

type GetResourceByIdentifierParams struct {
	WorkspaceID uuid.UUID
	Identifier  string
}

type GetResourceByIdentifierRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

func (q *Queries) GetResourceByIdentifier(ctx context.Context, arg GetResourceByIdentifierParams) (GetResourceByIdentifierRow, error) {
	row := q.db.QueryRow(ctx, getResourceByIdentifier, arg.WorkspaceID, arg.Identifier)
	var i GetResourceByIdentifierRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Name,
		&i.Kind,
		&i.Identifier,
		&i.ProviderID,
		&i.WorkspaceID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Metadata,
	)
	return i, err
}

const listResourceSummariesByIdentifiers = `-- name: ListResourceSummariesByIdentifiers :many
SELECT id, version, name, kind, identifier, provider_id, workspace_id,
       created_at, updated_at
FROM resource
WHERE workspace_id = $1 AND identifier = ANY($2::text[])
`

type ListResourceSummariesByIdentifiersParams struct {
	WorkspaceID uuid.UUID
	Column2     []string
}

type ListResourceSummariesByIdentifiersRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) ListResourceSummariesByIdentifiers(ctx context.Context, arg ListResourceSummariesByIdentifiersParams) ([]ListResourceSummariesByIdentifiersRow, error) {
	rows, err := q.db.Query(ctx, listResourceSummariesByIdentifiers, arg.WorkspaceID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourceSummariesByIdentifiersRow
	for rows.Next() {
		var i ListResourceSummariesByIdentifiersRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Name,
			&i.Kind,
			&i.Identifier,
			&i.ProviderID,
			&i.WorkspaceID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesByIdentifiers = `-- name: ListResourcesByIdentifiers :many
SELECT id, version, name, kind, identifier, provider_id, workspace_id,
       config, created_at, updated_at, deleted_at, metadata
FROM resource
WHERE workspace_id = $1 AND identifier = ANY($2::text[])
`

type ListResourcesByIdentifiersParams struct {
	WorkspaceID uuid.UUID
	Column2     []string
}

type ListResourcesByIdentifiersRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

func (q *Queries) ListResourcesByIdentifiers(ctx context.Context, arg ListResourcesByIdentifiersParams) ([]ListResourcesByIdentifiersRow, error) {
	rows, err := q.db.Query(ctx, listResourcesByIdentifiers, arg.WorkspaceID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesByIdentifiersRow
	for rows.Next() {
		var i ListResourcesByIdentifiersRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Name,
			&i.Kind,
			&i.Identifier,
			&i.ProviderID,
			&i.WorkspaceID,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesByProviderID = `-- name: ListResourcesByProviderID :many
SELECT id, version, name, kind, identifier, provider_id, workspace_id,
       config, created_at, updated_at, deleted_at, metadata
FROM resource
WHERE provider_id = $1
`

type ListResourcesByProviderIDRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

func (q *Queries) ListResourcesByProviderID(ctx context.Context, providerID uuid.UUID) ([]ListResourcesByProviderIDRow, error) {
	rows, err := q.db.Query(ctx, listResourcesByProviderID, providerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesByProviderIDRow
	for rows.Next() {
		var i ListResourcesByProviderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Name,
			&i.Kind,
			&i.Identifier,
			&i.ProviderID,
			&i.WorkspaceID,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcesByWorkspaceID = `-- name: ListResourcesByWorkspaceID :many
SELECT id, version, name, kind, identifier, provider_id, workspace_id,
       config, created_at, updated_at, deleted_at, metadata
FROM resource
WHERE workspace_id = $1
`

type ListResourcesByWorkspaceIDRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

func (q *Queries) ListResourcesByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]ListResourcesByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, listResourcesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesByWorkspaceIDRow
	for rows.Next() {
		var i ListResourcesByWorkspaceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Name,
			&i.Kind,
			&i.Identifier,
			&i.ProviderID,
			&i.WorkspaceID,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertResource = `-- name: UpsertResource :one
INSERT INTO resource (id, version, name, kind, identifier, provider_id, workspace_id,
                      config, created_at, updated_at, deleted_at, metadata)
VALUES ($1, $2, $3, $4, $5,
        NULLIF($6, '00000000-0000-0000-0000-000000000000'::uuid),
        $7, $8, $9, $10, $11, $12)
ON CONFLICT (workspace_id, identifier) DO UPDATE
SET id = EXCLUDED.id, version = EXCLUDED.version, name = EXCLUDED.name,
    kind = EXCLUDED.kind, provider_id = EXCLUDED.provider_id,
    config = EXCLUDED.config, updated_at = EXCLUDED.updated_at,
    deleted_at = EXCLUDED.deleted_at, metadata = EXCLUDED.metadata
RETURNING id, version, name, kind, identifier, provider_id, workspace_id,
         config, created_at, updated_at, deleted_at, metadata
`

type UpsertResourceParams struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

type UpsertResourceRow struct {
	ID          uuid.UUID
	Version     string
	Name        string
	Kind        string
	Identifier  string
	ProviderID  uuid.UUID
	WorkspaceID uuid.UUID
	Config      map[string]any
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	Metadata    map[string]string
}

func (q *Queries) UpsertResource(ctx context.Context, arg UpsertResourceParams) (UpsertResourceRow, error) {
	row := q.db.QueryRow(ctx, upsertResource,
		arg.ID,
		arg.Version,
		arg.Name,
		arg.Kind,
		arg.Identifier,
		arg.ProviderID,
		arg.WorkspaceID,
		arg.Config,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
		arg.Metadata,
	)
	var i UpsertResourceRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Name,
		&i.Kind,
		&i.Identifier,
		&i.ProviderID,
		&i.WorkspaceID,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Metadata,
	)
	return i, err
}
