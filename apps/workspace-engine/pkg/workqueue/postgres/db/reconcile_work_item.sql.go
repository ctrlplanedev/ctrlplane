// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reconcile_work_item.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimReconcileWorkItems = `-- name: ClaimReconcileWorkItems :many
WITH candidates AS (
  SELECT id
  FROM reconcile_work_item
  WHERE not_before <= now()
    AND (claimed_until IS NULL OR claimed_until < now())
  ORDER BY priority ASC, event_ts ASC, id ASC
  LIMIT $3
  FOR UPDATE SKIP LOCKED
)
UPDATE reconcile_work_item AS w
SET
  claimed_by = $1,
  claimed_until = now() + make_interval(secs => $2::int),
  updated_at = now()
FROM candidates AS c
WHERE w.id = c.id
RETURNING
  w.id,
  w.workspace_id,
  w.kind,
  w.scope_type,
  w.scope_id,
  w.event_ts,
  w.priority,
  w.not_before,
  w.attempt_count,
  COALESCE(w.last_error, '') AS last_error,
  COALESCE(w.claimed_by, '') AS claimed_by,
  w.claimed_until,
  w.updated_at
`

type ClaimReconcileWorkItemsParams struct {
	ClaimedBy    pgtype.Text
	LeaseSeconds int32
	BatchSize    int32
}

type ClaimReconcileWorkItemsRow struct {
	ID           int64
	WorkspaceID  uuid.UUID
	Kind         string
	ScopeType    string
	ScopeID      string
	EventTs      pgtype.Timestamptz
	Priority     int16
	NotBefore    pgtype.Timestamptz
	AttemptCount int32
	LastError    string
	ClaimedBy    string
	ClaimedUntil pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) ClaimReconcileWorkItems(ctx context.Context, arg ClaimReconcileWorkItemsParams) ([]ClaimReconcileWorkItemsRow, error) {
	rows, err := q.db.Query(ctx, claimReconcileWorkItems, arg.ClaimedBy, arg.LeaseSeconds, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimReconcileWorkItemsRow
	for rows.Next() {
		var i ClaimReconcileWorkItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Kind,
			&i.ScopeType,
			&i.ScopeID,
			&i.EventTs,
			&i.Priority,
			&i.NotBefore,
			&i.AttemptCount,
			&i.LastError,
			&i.ClaimedBy,
			&i.ClaimedUntil,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const claimReconcileWorkItemsByKinds = `-- name: ClaimReconcileWorkItemsByKinds :many
WITH candidates AS (
  SELECT id
  FROM reconcile_work_item
  WHERE not_before <= now()
    AND (claimed_until IS NULL OR claimed_until < now())
    AND kind = ANY($3::text[])
  ORDER BY priority ASC, event_ts ASC, id ASC
  LIMIT $4
  FOR UPDATE SKIP LOCKED
)
UPDATE reconcile_work_item AS w
SET
  claimed_by = $1,
  claimed_until = now() + make_interval(secs => $2::int),
  updated_at = now()
FROM candidates AS c
WHERE w.id = c.id
RETURNING
  w.id,
  w.workspace_id,
  w.kind,
  w.scope_type,
  w.scope_id,
  w.event_ts,
  w.priority,
  w.not_before,
  w.attempt_count,
  COALESCE(w.last_error, '') AS last_error,
  COALESCE(w.claimed_by, '') AS claimed_by,
  w.claimed_until,
  w.updated_at
`

type ClaimReconcileWorkItemsByKindsParams struct {
	ClaimedBy    pgtype.Text
	LeaseSeconds int32
	Kinds        []string
	BatchSize    int32
}

type ClaimReconcileWorkItemsByKindsRow struct {
	ID           int64
	WorkspaceID  uuid.UUID
	Kind         string
	ScopeType    string
	ScopeID      string
	EventTs      pgtype.Timestamptz
	Priority     int16
	NotBefore    pgtype.Timestamptz
	AttemptCount int32
	LastError    string
	ClaimedBy    string
	ClaimedUntil pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) ClaimReconcileWorkItemsByKinds(ctx context.Context, arg ClaimReconcileWorkItemsByKindsParams) ([]ClaimReconcileWorkItemsByKindsRow, error) {
	rows, err := q.db.Query(ctx, claimReconcileWorkItemsByKinds,
		arg.ClaimedBy,
		arg.LeaseSeconds,
		arg.Kinds,
		arg.BatchSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClaimReconcileWorkItemsByKindsRow
	for rows.Next() {
		var i ClaimReconcileWorkItemsByKindsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Kind,
			&i.ScopeType,
			&i.ScopeID,
			&i.EventTs,
			&i.Priority,
			&i.NotBefore,
			&i.AttemptCount,
			&i.LastError,
			&i.ClaimedBy,
			&i.ClaimedUntil,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteClaimedReconcileWorkItemIfUnchanged = `-- name: DeleteClaimedReconcileWorkItemIfUnchanged :execrows
DELETE FROM reconcile_work_item
WHERE id = $1
  AND claimed_by = $2
  AND updated_at <= $3
`

type DeleteClaimedReconcileWorkItemIfUnchangedParams struct {
	ID        int64
	ClaimedBy pgtype.Text
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) DeleteClaimedReconcileWorkItemIfUnchanged(ctx context.Context, arg DeleteClaimedReconcileWorkItemIfUnchangedParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteClaimedReconcileWorkItemIfUnchanged, arg.ID, arg.ClaimedBy, arg.UpdatedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const extendReconcileWorkItemLease = `-- name: ExtendReconcileWorkItemLease :execrows
UPDATE reconcile_work_item
SET
  claimed_until = now() + make_interval(secs => $1::int),
  updated_at = now()
WHERE id = $2
  AND claimed_by = $3
`

type ExtendReconcileWorkItemLeaseParams struct {
	LeaseSeconds int32
	ID           int64
	ClaimedBy    pgtype.Text
}

func (q *Queries) ExtendReconcileWorkItemLease(ctx context.Context, arg ExtendReconcileWorkItemLeaseParams) (int64, error) {
	result, err := q.db.Exec(ctx, extendReconcileWorkItemLease, arg.LeaseSeconds, arg.ID, arg.ClaimedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const releaseReconcileWorkItemClaim = `-- name: ReleaseReconcileWorkItemClaim :execrows
UPDATE reconcile_work_item
SET
  claimed_by = NULL,
  claimed_until = NULL,
  updated_at = now()
WHERE id = $1
  AND claimed_by = $2
`

type ReleaseReconcileWorkItemClaimParams struct {
	ID        int64
	ClaimedBy pgtype.Text
}

func (q *Queries) ReleaseReconcileWorkItemClaim(ctx context.Context, arg ReleaseReconcileWorkItemClaimParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseReconcileWorkItemClaim, arg.ID, arg.ClaimedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const retryReconcileWorkItem = `-- name: RetryReconcileWorkItem :execrows
UPDATE reconcile_work_item
SET
  attempt_count = attempt_count + 1,
  last_error = $1,
  not_before = now() + make_interval(secs => $2::int),
  claimed_by = NULL,
  claimed_until = NULL,
  updated_at = now()
WHERE id = $3
  AND claimed_by = $4
`

type RetryReconcileWorkItemParams struct {
	LastError           pgtype.Text
	RetryBackoffSeconds int32
	ID                  int64
	ClaimedBy           pgtype.Text
}

func (q *Queries) RetryReconcileWorkItem(ctx context.Context, arg RetryReconcileWorkItemParams) (int64, error) {
	result, err := q.db.Exec(ctx, retryReconcileWorkItem,
		arg.LastError,
		arg.RetryBackoffSeconds,
		arg.ID,
		arg.ClaimedBy,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertReconcileWorkItem = `-- name: UpsertReconcileWorkItem :exec
INSERT INTO reconcile_work_item (
  workspace_id, kind, scope_type, scope_id, event_ts, priority, not_before,
  attempt_count, last_error, claimed_by, claimed_until, created_at, updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, 0, NULL, NULL, NULL, now(), now()
)
ON CONFLICT (workspace_id, kind, scope_type, scope_id)
DO UPDATE SET
  event_ts = GREATEST(reconcile_work_item.event_ts, EXCLUDED.event_ts),
  priority = LEAST(reconcile_work_item.priority, EXCLUDED.priority),
  not_before = LEAST(reconcile_work_item.not_before, EXCLUDED.not_before),
  updated_at = now(),
  last_error = NULL,
  claimed_by = CASE
    WHEN reconcile_work_item.claimed_until IS NOT NULL
      AND reconcile_work_item.claimed_until < now()
    THEN NULL
    ELSE reconcile_work_item.claimed_by
  END,
  claimed_until = CASE
    WHEN reconcile_work_item.claimed_until IS NOT NULL
      AND reconcile_work_item.claimed_until < now()
    THEN NULL
    ELSE reconcile_work_item.claimed_until
  END
`

type UpsertReconcileWorkItemParams struct {
	WorkspaceID uuid.UUID
	Kind        string
	ScopeType   string
	ScopeID     string
	EventTs     pgtype.Timestamptz
	Priority    int16
	NotBefore   pgtype.Timestamptz
}

func (q *Queries) UpsertReconcileWorkItem(ctx context.Context, arg UpsertReconcileWorkItemParams) error {
	_, err := q.db.Exec(ctx, upsertReconcileWorkItem,
		arg.WorkspaceID,
		arg.Kind,
		arg.ScopeType,
		arg.ScopeID,
		arg.EventTs,
		arg.Priority,
		arg.NotBefore,
	)
	return err
}
